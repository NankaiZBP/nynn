// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "DataXMaster.h"
#include "DataX.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::nynn::mm;

struct GlobalControl_t
{
	uint32_t _npeer;
	map<string,uint32_t> _index;
	xletter_t _stub;
	unique_ptr<monitor_t> _monitor;

	vector<shared_ptr<DataXPeerClient> > _peer;
	vector<shared_ptr<monitor_t> > _barrier;

	GlobalControl_t():_npeer(0),monitor(new monitor_t())
	{
		const char* cfgfile=getenv("NYNN_MM_CONFIG_FILE");
		_stub._iaddr_table.resize(0);
		loadconfig(cfgfile,_stub._iaddr_table);
		if(_stub._iaddr_table.size()==0){
			log_w("config file '%s' is ill-formed or can't load config file");
			exit(0);
		}
		
		vector<xinetaddr_t> &iaddr_table=_stub._iaddr_table;
		_peer.resize(iaddr_table.size());
		_barrier.resize(iaddr_table.size());

		for(int i=0;i<iaddr_table.size();i++){
			xinetaddr_t &iaddr=iaddr_table[0];
			_index[iaddr._hostname]=i;
			_barrier[i]->reset(new monitor_t());
			pthread_mutex_lock(_barrier[i]->get());
		}
	}

	void sign(xletter_t& quest){
		
		if (quest._iaddr_table.size()!=1){
			log_w("Something wrong with iaddr_table of quest");
			exit(0);
		}

		xinetaddr_t &iaddr=quest._iaddr_table[0];
		if (_index.find(iaddr._hostname)!=_index.end()){
			log_w("A unknown DataXceiver '%s' trys to access DataXServer",iaddr.hostname);
			exit(0);
		}

		uint32_t IDX=_index[iaddr._hostname];		
		vector<xchunk_entry_t> &chk_table=_stub._chk_table;
		do{
			//enter critical area
			synchronized_t s(_monitor);

			//insert partial chunk table into global chunk table.
			vector<xchunk_entry_t>::iterator begin=quest._chk_table.begin();
			vector<xchunk_entry_t>::iterator end=quest._chk_table.end();
			chk_table.insert(chk_table.end(),begin,end);
		
			//create client for every DataXceiver.
			string &hostname=iaddr._hostname;
			uint16_t port=iaddr._port;
			boost::shared_ptr<TTransport> socket(new TSocket(hostname,port));	
			boost::shared_ptr<TTransport> transport(new TFramedTransport(socket));
			boost::shared_ptr<TProtocol>  protocol(new TBinaryProtocol(transport));
			_peer[IDX].reset(new DataXPeerClient(protocol));
			//record the number of DataXceiver.	
			_npeer++;
		}while(0);

		if (_npeer==iaddr_table.size()){
			for(int i=0;i<_barrier.size();i++){
				pthread_mutex_unlock(_barrier[i]->mutex());
			}
		}

		pthread_mutex_lock(_barrier[IDX]->mutex());
		pthread_mutex_unlock(_barrier[IDX]->mutex());
	}
}

class DataXMasterHandler : virtual public DataXMasterIf {
 public:
  DataXMasterHandler() {
    // Your initialization goes here
  }

  void submit(xletter_t& _return, const xletter_t& quest) {
    // Your implementation goes here
	GlobalCntl.sign(quest);
	_return=GlobalCntl._stub;
  }

  bool update(const std::vector<std::vector<int8_t> > & data) {
    // Your implementation goes here
    printf("update\n");
  }

};

int main(int argc, char **argv) {
//  int port = 9090;
//  shared_ptr<DataXMasterHandler> handler(new DataXMasterHandler());
//  shared_ptr<TProcessor> processor(new DataXMasterProcessor(handler));
//  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
//  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
//  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());
//  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
//  server.serve();
  int port = 40001;
  boost::shared_ptr<DataXMasterHandler> handler(new DataXMasterHandler());
  boost::shared_ptr<TProcessor> processor(new DataXMasterProcessor(handler));
  boost::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  boost::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());
  boost::shared_ptr<ThreadFactory> pthreadFactory(new PosixThreadFactory());

  boost::shared_ptr<ThreadManager> threadManager=ThreadManager::newSimpleThreadManager(10,4);
  threadManager->threadFactory(pthreadFactory);

  TNonblockingServer server(processor,transportFactory,transportFactory,protocolFactory,protocolFactory,port,threadManager);
  threadManager->start();
  server.serve();
  return 0;
}

