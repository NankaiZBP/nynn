// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "DataXMaster.h"
#include "DataX.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <boost/shared_ptr.hpp>
using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace ::apache::thrift::concurrency;

using boost::shared_ptr;
using namespace  ::nynn::mm;
using namespace  ::nynn::mm::common;
struct GlobalControl_t
{
	uint32_t _npeer;
	map<string,uint32_t> _index;
	xletter_t _stub;
	boost::shared_ptr<monitor_t> _monitor;
	vector<boost::shared_ptr<TTransport> > _transport;
	vector<boost::shared_ptr<DataXPeerClient> > _peer;
	vector<boost::shared_ptr<monitor_t> > _barrier;

	GlobalControl_t():_npeer(0),_monitor(new monitor_t())
	{
		const char* cfgfile=getenv("NYNN_MM_CONFIG_FILE");
		_stub._iaddr_table.resize(0);
		loadconfig(cfgfile,_stub._iaddr_table);
		if(_stub._iaddr_table.size()==0){
			log_w("config file '%s' is ill-formed or can't load config file");
			exit(0);
		}
		
		vector<xinetaddr_t> &iaddr_table=_stub._iaddr_table;

		_transport.resize(iaddr_table.size());
		_peer.resize(iaddr_table.size());
		_barrier.resize(iaddr_table.size());

		for(int i=0;i<iaddr_table.size();i++){
			xinetaddr_t &iaddr=iaddr_table[0];
			_index[iaddr._hostname]=i;
			_barrier[i].reset(new monitor_t());
			pthread_mutex_lock(_barrier[i]->mutex());
		}
	}

	void sign(const xletter_t& quest){
		
		if (quest._iaddr_table.size()!=1){
			log_w("Something wrong with iaddr_table of quest");
			exit(0);
		}

		const xinetaddr_t &iaddr=quest._iaddr_table[0];
		if (_index.find(iaddr._hostname)!=_index.end()){
			log_w("A unknown DataXceiver '%s' trys to access DataXServer",
					iaddr._hostname.c_str());
			exit(0);
		}

		uint32_t IDX=_index[iaddr._hostname];		
		vector<xchunk_entry_t> &chk_table=_stub._chk_table;
		do{
			//enter critical area
			synchronized_t s(_monitor.get());

			//insert partial chunk table into global chunk table.
			vector<xchunk_entry_t>::const_iterator begin=quest._chk_table.cbegin();
			vector<xchunk_entry_t>::const_iterator end=quest._chk_table.cend();
			chk_table.insert(chk_table.end(),begin,end);
		
			//create client for every DataXceiver.
			string hostname=iaddr._hostname;
			uint16_t port=iaddr._port;
			boost::shared_ptr<TTransport> socket(new TSocket(hostname,port));	
			_transport[IDX].reset(new TFramedTransport(socket));
			boost::shared_ptr<TProtocol>  protocol(new TBinaryProtocol(_transport[IDX]));
			_peer[IDX].reset(new DataXPeerClient(protocol));
			//record the number of DataXceiver.	
			_npeer++;
		}while(0);

		vector<xinetaddr_t>& iaddr_table=_stub._iaddr_table;
		if (_npeer==iaddr_table.size()){
			for(int i=0;i<_barrier.size();i++){
				pthread_mutex_unlock(_barrier[i]->mutex());
			}
		}

		do{
			try{
				_transport[IDX]->open();
				cout<<"succeed in connecting DataXceiver("<<iaddr._hostname
					<<","<<iaddr._port<<endl;
				break;
			}catch(TException &tx){
				cout<<"try to connecting DataXceiver("<<iaddr._hostname
					<<","<<iaddr._port<<endl;
			}

		}while(1);

		pthread_mutex_lock(_barrier[IDX]->mutex());
		pthread_mutex_unlock(_barrier[IDX]->mutex());
	}
} GlobalCntl;
class DataXMasterHandler : virtual public DataXMasterIf {
 public:
  DataXMasterHandler() {
    // Your initialization goes here
  }

  void submit(xletter_t& _return, const xletter_t& quest) {
    // Your implementation goes here
    //printf("submit\n");
	GlobalCntl.sign(quest);
	_return=GlobalCntl._stub;
  }

  bool update(const std::vector<xedge_t> & edge) {
    // Your implementation goes here
    printf("update\n");
  }

};

int main(int argc, char **argv) {
  //int port = 9090;
  //shared_ptr<DataXMasterHandler> handler(new DataXMasterHandler());
  //shared_ptr<TProcessor> processor(new DataXMasterProcessor(handler));
  //shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  //shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  //shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  //TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  //server.serve();
  int port = 40001;
  boost::shared_ptr<DataXMasterHandler> handler(new DataXMasterHandler());
  boost::shared_ptr<TProcessor> processor(new DataXMasterProcessor(handler));
  boost::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  boost::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());
  boost::shared_ptr<ThreadFactory> pthreadFactory(new PosixThreadFactory());

  boost::shared_ptr<ThreadManager> threadManager=ThreadManager::newSimpleThreadManager(10,4);
  threadManager->threadFactory(pthreadFactory);

  TNonblockingServer server(processor,transportFactory,transportFactory,protocolFactory,protocolFactory,port,threadManager);
  threadManager->start();
  server.serve();
  return 0;
}

