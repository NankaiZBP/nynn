// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "DataXPeer.h"
#include "DataX.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace ::apache::thrift::concurrency;
using boost::shared_ptr;

using namespace  ::nynn::mm;
using namespace  ::nynn::mm::common;
class DataXPeerHandler;
struct PeerControl
{
	boost::shared_ptr<ThreadFactory> _pthread;
	boost::shared_ptr<DataXMasterClient> _master;
	map<string,uint32_t> _index;
	vector<boost::shared_ptr<TSocket> > _socket;
	vector<boost::shared_ptr<DataXPeerClient> > _peer;
	context_t *_ctx;
	xletter_t _stub;

	PeerControl()
	{
		const char* serverhost=getenv("DATAX_SERVER_HOST");
		uint16_t serverport=atoi(getenv("DATAX_SERVER_PORT"));

		_pthread.reset(new PosixThreadFactory());

		boost::shared_ptr<TSocket> socket(new TSocket(serverhost,serverport));	
		boost::shared_ptr<TTransport> transport(new TFramedTransport(socket));
		boost::shared_ptr<TProtocol>  protocol(new TBinaryProtocol(transport));
		_master.reset(new DataXMasterClient(protocol));
		do{
			try{
				transport->open();
				cout<<"succeed in connecting DataXServer("<<serverhost<<","
					<<serverport<<")"<<endl;
				break;
			}catch(TException &tx){
				cerr<<"try to connect DataXServer("<<serverhost<<","
					<<serverport<<")"<<endl;
			}
		}while(1);
		_ctx=context_t::get_context();
	}

	void submit()
	{
		xinetaddr_t iaddr;
		iaddr._hostname.reserve(64);
		iaddr._hostaddr=gethostaddr(iaddr._hostname);
		iaddr._port=atoi(getenv("DATAX_CEIVER_PORT"));
		_stub._iaddr_table.resize(0);
		_stub._iaddr_table.push_back(iaddr);

		meta_type *meta=_ctx->get_meta();
		int nchkentry=meta->get_chunkentrynum();
		_stub._chk_table.reserve(nchkentry);
		
		chunk_entry_t  *chkentry;
		xchunk_entry_t xchkentry;
		for(int i=0;i<nchkentry;i++){
			chkentry=meta->get_chunkentry(i);
			xchkentry._path=chkentry->_path;
			xchkentry._maxvtx=chkentry->_maxvtx;
			xchkentry._minvtx=chkentry->_minvtx;
			xchkentry._flag=chkentry->_flag;			
			xchkentry._where=chkentry->_where;
			_stub._chk_table.push_back(xchkentry);
		}
		_master->submit(_stub,_stub);
		log_i("recommendation has been submited!");
		
		vector<xinetaddr_t> &iaddr_table=_stub._iaddr_table;
		_socket.resize(0);
		_socket.reserve(iaddr_table.size());
		_peer.resize(0);
		_peer.reserve(iaddr_table.size());

		for (int i=0;i<iaddr_table.size();i++){
			xinetaddr_t &iaddr=iaddr_table[i];
			_index[iaddr._hostname]=i;
			boost::shared_ptr<TSocket> socket(new TSocket(iaddr._hostname,iaddr._port));
			boost::shared_ptr<TTransport> transport(new TFramedTransport(socket));
			boost::shared_ptr<TProtocol>  protocol(new TBinaryProtocol(transport));
			_socket.push_back(socket);
			boost::shared_ptr<DataXPeerClient> client(new DataXPeerClient(protocol));
			_peer.push_back(client);
		}

	}

}PeerCntl;
class DataXPeerHandler : virtual public DataXPeerIf {
	public:
		DataXPeerHandler() {
			// Your initialization goes here
		}

		void read(std::vector<std::vector<int8_t> > & _return, const std::string& hostname, const int64_t vtxno, const int32_t blkno) {
			// Your implementation goes here
			printf("read\n");
		}

		void fetch(std::vector<std::vector<int8_t> > & _return, const int64_t vtxno, const int32_t blkno) {
			// Your implementation goes here
			printf("fetch\n");
		}

		bool write(const xvertex_t& vtx) {
			// Your implementation goes here
			printf("write\n");
		}

};

class StartServerTask:public Runnable{
	uint16_t _port;
	public:
	StartServerTask(uint16_t port):_port(port){}
	void run()
	{
		boost::shared_ptr<DataXPeerHandler> handler(new DataXPeerHandler());
		boost::shared_ptr<TProcessor> processor(new DataXPeerProcessor(handler));
		boost::shared_ptr<TTransportFactory> 
			transportFactory(new TBufferedTransportFactory());
		boost::shared_ptr<TProtocolFactory> 
			protocolFactory(new TBinaryProtocolFactory());
		boost::shared_ptr<ThreadFactory> 
			pthreadFactory(new PosixThreadFactory());
		boost::shared_ptr<ThreadManager> 
			threadManager=ThreadManager::newSimpleThreadManager(10,4);
		threadManager->threadFactory(pthreadFactory);

		TNonblockingServer 
			server(
					processor,
					transportFactory,
					transportFactory,
					protocolFactory,
					protocolFactory,
					_port,
					threadManager
				  );
		threadManager->start();
		server.serve();
	}
};

class CreateConnectionTask:public Runnable{
	boost::shared_ptr<TSocket> _socket;
public:
	CreateConnectionTask(boost::shared_ptr<TSocket> socket):_socket(socket){}

	void run()
	{
		do{
			try{
				_socket->open();
				
				log_i("succeed in connecting DataXceiver(%s:%d)",
						_socket->getHost().c_str(),_socket->getPort());
				break;
			}catch(TException &tx){
				log_i("try to connect DataXceiver(%s:%d)",
						_socket->getHost().c_str(),_socket->getPort());
			}

		}while(1);
	}
};


int main(int argc, char **argv) {
	//step 0:
	//DataXServer Daemon is started.
	//step 1:
	//before executing main, connection(DataXceiver->DataXServer) has been established.
	//this connection is established while initializing PeerControl Object.
	//step 2:
	//DataXceiver Daemon is started.
	//step 3:
	//DataXceivers submit recommendation letters to DataXServer,then perform global 
	//synchronization,after that, DataXServer gathers partial info into a whole info
	//and replys DataXceiver.
	//step 4:
	//DataXceivers connects each other.
	uint16_t port=atoi(getenv("DATAX_CEIVER_PORT"));
	boost::shared_ptr<Runnable> startServ(new StartServerTask(port));
	boost::shared_ptr<Thread> startServThd=PeerCntl._pthread->newThread(startServ);
	startServThd->start();
	PeerCntl.submit();
	for(int i=0;i<PeerCntl._socket.size();i++){
		boost::shared_ptr<Runnable> createConn(new CreateConnectionTask(PeerCntl._socket[i]));
		boost::shared_ptr<Thread>   createConnThd=PeerCntl._pthread->newThread(createConn);
		createConnThd->start();
	}

	return 0;
}

